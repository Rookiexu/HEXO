layout: '[layout]'
title: '基础知识整理'
date: 2017-02-17 21:16:44 
description: 之前找工作的时候整理过的一份文档，画出来我觉得的一些重点，有些东西因为自己还比较熟只是标记了没有写进去。
tags: [人生总结]
---

# **数据库** #


## 范式  ##
	
	
第一范式：数据库表的每一项都是不可分割的原子数据项，不能是集合。比如班级信息表里面不能有班级的学生。 

第二范式：在第一范式的基础上，所有属性完全依赖于主键，完全依赖就是不能取决于主键的一部分 


第三范式：在第二范式的基础上，消除传递依赖，比如学生表里有学生属于的班级编号，但不能有班级的名称，班级人数等班级信息，因为班级信息可有由班级编号通过班级表推出来，有传递依赖 

第一范式->第二范式->第三范式 

→→→数据冗余越来越少，查询越来越复杂 

←←←有数据冗余，但查询简单

************************
## 事务  ##
	
并发控制的单位，是用户定义的一个操作序列，要么全做，要么全不做，是不可分割的。 


1原子性 


2一致性： 


使数据库从一个一致性状态到另一个一致性状态 


3隔离性： 


一个事物的执行不被其他事务干扰 


4永久性： 


一个事务一旦提交，它对数据库的改变就是永久性的

## 常用SQL语句 ##

分组查询（avg max min）、复杂连接查询、嵌套查询、结果排序（逆序ansc）
************************
# HTML错误代码 #

(1) 常见错误代码：

200服务器成功返回了网页，成功处理了请求

304未修改，自从上次请求后，请求的页面未被修改过，此时服务器不会返回网页内容，节省带宽和开销

404请求的网页不存在

500服务器内部错误

503服务器暂时不可用（超载、停机维护），通常只是暂时状态

(2) 1xx：临时响应，服务器端响应成功，等待请求者进一步操作

(3) 2xx：响应成功 

202接受请求，未处理

204处理了请求，但没有返回任何内容

(4) 3xx重定向，要完成响应，服务器需要进一步处理

301网页已被永久移动到新位置

302临时移动到新位置

305要求只能使用代理才能访问

(5) 4xx请求错误

400不理解请求语法

401要求身份验证，先登陆才能请求

403禁止访问，服务器拒绝请求

405请求中的方法被禁用

408请求超时

(6) 5xx服务器在处理请求时内部发生错误，来自服务器本身的错误

501服务器不具备完成该请求的功能

502服务器作为网关或代理，从上游服务器收到无效响应

504网关超时
505  HTTP版本不支持
************************
# 设计模式 #
##  MVC ##
## 单例 ##
## 简单工厂、工厂方法、抽象工厂 ##

************************

# LINUX #

## 权限命令 ##

改变权限  
chmod 777 filepath 指定文件filepath为所有用户可读，可写，可执行
读写执行分别对应数字1 2 4，加起来就是7  
改变所有者  
chown test filepath   
改变filepath 的所有者为test
改变所属组
chgrp user filepath
改变filepath 的所属组为user

##  常用命令 ##

ls cd pwd cp chmod chwon等 

************************
# 数据结构 #
链表

反转、找到中间元素等
树

二叉树
霍夫曼树

带权路径最小的最优树

二叉、红黑等树，遍历
图
队列
堆
栈

************************
# Java基础 #

# 抽象和接口 #
抽象类：抽象类往往用来表征我们在对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象，我们不能把它们实例化（拿不出一个具体的东西）所以称之为抽象。在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为这个抽象类的所有派生类。

接口：Java中的接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。

区别：1)从设计理念层面上：abstract class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a"关系，即父类和派生类在概念本质上应该是相同的。对于interface来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已，接口与实现类 之间的关系是"like-a"的关系。(举例：class AlarmDoor extends Door implements Alarm)；2)从语法定义层面上：在abstract class方式中，抽象类可以有自己的数据成员，也可以有非 abstract的成员方法，而在interface方式的实现中，只能有有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的 abstract class。abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑。在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为。

## overload和override的区别  ##

overload是重载，是同一个类中有相同的方法名，但参数类型或个数彼此不同。1)参数类型、个数、顺序至少有一个不相同。2)不能重载只有返回值不同的方法名。3)存在于父类和子类、同类中。

override是重写，是在子类与父类中，子类中的方法的方法名，参数个数、类型都与父类中的完全一样，在子类中覆盖掉了父类的改方法 。
1)方法名、参数、返回值相同。  
2)子类方法不能缩小父类方法的访问权限。  
3)子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。  
4)存在于父类和子类之间。  
5)方法被定义为final不能被重写。  

## String与StringBuffer的区别  ##

1. 区别一
2. 区别二 equals方法  String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。

## java集合框架结构(Map,List,Set......) ##

### ArrayList,Vector容量相关问题 ###

ArrayList:如果以new ArrayList()方式创建时，初始容量为10个；如果以new ArrayList(Collection c)初始化时，容量为c.size()*1.1，即增加10%的容量；当向ArrayList中添加一个元素时，先进行容器的容量调整，如果容量不够时，则增加至原来的1.5倍加1，再然后把元素加入到容器中，即以原始容量的0.5倍比率增加。

Vector:初始化时容量可以设定，如果以new Vector()方式创建时，则初始容量为10，超过容量时以2倍容量增加。如果以new Vector(Collection c)方式创建时，初始容量为c.size()*1.1，超过时以2倍容量增加。如果以new Vector(int initialCapacity, int capacityIncrement)，则以capacityIncrement容量增加。

### 集合特点 ###

List：保证以某种特定插入顺序来维护元素顺序，即保持插入的顺序，另外元素可以重复。  

ArrayList：是用数组实现的，读取速度快，插入与删除速度慢（因为插入与删除时要移动后面的元素），适合于随机访问。 
 
Vector：功能与ArrayList几乎相同，也是以数组实现，添加，删除，读取，设置都是基于线程同步的。

LinkedList：双向链表来实现，删除与插入速度快，读取速度较慢，因为它读取时是从头向尾（如果节点在链的前半部分），或尾向头（如果节点在链的后半部分）查找元素。因此适合于元素的插入与删除操作。 
 
Set：维持它自己的内部排序，随机访问不具有意义。另外元素不可重复。  

HashSet：是最常用的，查询速度最快，因为 内部以HashMap来实现，所以插入元素不能保持插入次序。  

LinkedHashSet：继承了HashSet，保持元素的插入次序，因为内部使用LinkedHashMap实现，所以能保持元素插入次序。 
 
TreeSet：基于TreeMap，生成一个总是处于排序状态的set，它实现了SortedSet接口，内部以 TreeMap来实现  

TreeMap：键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口，具体可参《RED-BLACK(红黑)树的实现TreeMap源码阅读 》  

HashMap: 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。  

Hashtable:也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低。  

LinkedHashMap:继承HashMap，内部实体LinkedHashMap.Entry继承自HashMap.Entry，LinkedHashMap.Entry在HashMap.Entry的基础上新增了两个实体引用（Entry before, after），这样实体可以相互串链起来形成链，并且在LinkedHashMap中就定义了一个头节点（Entry header）用来指向循环双向链的第一个元素（通过after指向）与最后一个元素（通过before指向）。在添加一个元素时，先会通过父类HashMap将元素加入到hash表数组里，然后再会在链尾（header.before指向位置）添加（当然这一过程只是调整LinkedHashMap.Entry对象内部的before, after而已，而不是真真创建一个什么新的链表结构向里加那样）；删除先从hash表数组中删除，再将被删除的元素彻底的从双向链中断开。其实在链中添加与删除操作与LinkedList是一样的，可以参考《Java集合框架之LinkedList及ListIterator实现源码分析 》   

### HashMap与HashTable的区别 ###
Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程应用程序中，我们应该使用Hashtable；而对于HashMap，则需要额外的同步机制。但HashMap的同步问题可通过Collections的一个静态方法得到解决：Map Collections.synchronizedMap(Map m)，当然与可以自己在使用地方加锁。  
在HashMap中，可以允许null作为键，且只可以有一个，否则覆盖，但可以有一个或多个值为null。因为当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null，所以HashMap不能由get()方法来判断否存在某个键，而应该用containsKey()方法来判断；而Hashtable不允许null键与null值。  
HashTable使用Enumeration，HashMap使用Iterator。  
Hashtable是Dictionary的子类，HashMap是Map接口的一个实现类；

### 集合中键值是否允许null小结 ###
  
List：可以有多个null，可以有重复值  

HashSet：能插入一个null（因为内部是以 HashMap实现 ），忽略不插入重复元素。 
 
TreeSet：不能插入null （因为内部是以 TreeMap 实现 ） ，元素不能重复，如果待插入的元素存在，则忽略不插入，对元素进行排序。  

HashMap：允许一个null键与多个null值，若重复键，则覆盖以前值。  

TreeMap：不允许null键(实际上可以插入一个null键，如果这个Map里只有一个元素是不会报错的，因为一个元素时没有进行排序操作，也就不会报空指针异常，但如果插入第二个时就会立即报错)，但允许多个null值，覆盖已有键值。  

HashTable：不允许null键与null值(否则运行进报空指针异常)。也会覆盖以重复值。基于线程同步。

### 对List的选择 ###

对于随机查询与迭代遍历操作，数组比所有的容器都要快。

从中间的位置插入和删除元素，LinkedList要比ArrayList快，特别是删除操作。

Vector通常不如ArrayList快，则且应该避免使用，它目前仍然存在于类库中的原因是为了支持过去的代码。

最佳实践：将ArrayList作为默认首选，只有当程序的性能因为经常从list中间进行插入和删除而变差的时候，才去选择LinkedList。当然了，如果只是使用固定数量的元素，就应该选择数组了。

### 对Set的选择 ###

HashSet的性能总比TreeSet好(特别是最常用的添加和查找元素操作)。

TreeSet存在的唯一原因是，它可以维持元素的排序状态，所以只有当你需要一个排好序的Set时，才应该使用TreeSet。

对于插入操作，LinkedHashSet比HashSet略微慢一点：这是由于维护链表所带来额外

### 对Map的选择 ###

Hashtable和HashMap的效率大致相同(通常HashMap更快一点，所以HashMap有意取代Hashtable)。

TreeMap通常比HashMap慢，因为要维护排序。

HashMap正是为快速查询而设计的。

LinkedHashMap比HashMap慢一点，因为它维护散列数据结构的同时还要维护链表。

### hashCode(),equals()方法 ###

## Java 线程 ##

### 线程概念，线程与进程 ###
线程：线程是“进程”中某个单一顺序的控制流。也被称为轻量进程。线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程不拥有系统资源，只有运行必须的一些数据结构；它与父进程的其它线程共享该进程所拥有的全部资源。进程可以创建和撤消线程，从而实现程序的并发执行。

进程：进程是操作系统结构的基础；是一个正在执行的程序；计算机中正在运行的程序实例；可以分配给处理器并由处理器执行的一个实体；由单一顺序的执行显示，一个当前状态和一组相关的系统资源所描述的活动单元。

线程与进程：有时候，线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。发生进程切换与发生线程切换时相比较，进程切换时涉及到有关资源指针的保存以及地址空间的变化等问题；线程切换时，由于同不进程内的线程共享资源和地址空间，将不涉及资源信息的保存和地址变化问题，从而减少了操作系统的开销时间。而且，进程的调度与切换都是由操作系统内核完成，而线程则既可由操作系统内核完成，也可由用户程序进行。

### 线程的状态 ###

### 线程同步与死锁 ###
同步：许多线程在执行中必须考虑与其他线程之间共享数据或协调执行状态。这就需要同步机制。在Java中每个对象都有一把锁与之对应。但Java不提供单独的lock和unlock操作。它由高层的结构隐式实现, 来保证操作的对应。(然而,我们注意到Java虚拟机提供单独的monito renter和monitorexit指令来实现lock和unlock操作。) 

synchronized语句计算一个对象引用,试图对该对象完成锁操作, 并且在完成锁操作前停止处理。当锁操作完成synchronized语句体得到执行。当语句体执行完毕(无论正常或异常),解锁操作自动完成。作为面向对象的语言,synchronized经常与方法连用。一种比较好的办法是,如果某个变量由一个线程赋值并由别的线程引用或赋值,那么所有对该变量的访问都必须在某个synchromized语句或synchronized方法内。

死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。如果程序中有几个竞争资源的并发线程,那么保证均衡是很重要的。系统均衡是指每个线程在执行过程中都能充分访问有限的资源。系统中没有饿死和死锁的线程。Java并不提供对死锁的检测机制。对大多数的Java程序员来说防止死锁是一种较好的选择。最简单的防止死锁的方法是对竞争的资源引入序号,如果一个线程需要几个资源,那么它必须先得到小序号的资源,再申请大序号的资源。

### java线程创建与启动 ###

两种方式创建线程：扩展java.lang.Thread类、实现java.lang.Runnable接口。

启动线程：在线程的Thread对象上调用start()方法，而不是run()或者别的方法。在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。在调用start()方法之后：发生了一系列复杂的事情：启动新的执行线程（具有新的调用栈）；该线程从新状态转移到可运行状态；当该线程获得机会执行时，其目标run()方法将运行。

线程的名字：一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是main，非主线程的名字不确定。线程都可以设置名字，也可以通过Thread.currentThread()获取线程的名字。

### java的优先级 ###
线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。

### wait()，sleep()，yield()，join()，notify()，notifyAll() ###
wait():是Object 类的方法，对此对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 
sleep():是Thread类的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep() 不会释放对象锁。
yield():方法只是把线程的状态有执行状态打回准备就绪状态，所以，执行这个方法后，有可能马上又开始运行，有可能等待很长时间，yield()方法只能让同优先级的线程有执行的机会，调用yield()不会释放对象锁。 yield()方法先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程。

join()： join()方法使调用该方法的线程在此之前执行完毕，也就是等待调用该方法的线程执行完毕后再往下继续执行。 join() 方法主要是让调用该方法的thread完成run方法里面的东西后， 在执行join()方法后面的代码。

t.join():表示当前线程停止执行直到t线程运行完毕；
t.join(1000): 表示当前线程等待t线程运行1000后执行；

notify()/notifyAll()：notify和notifyAll都是把某个对象上休息区内的线程唤醒，notify只能唤醒一个，但究竟是哪一个不能确定，而notifyAll则唤醒这个对象上的休息室中所有的线程。





















********************
# 特别部分 #
AOP实现
mybatis多对多配置